[{"title":"【面试相关】Java集合","path":"/posts/51727.html","content":"Java的集合类主要由两个接口派生出来的：分别是：Collection、Map Java集合框架概述 数组和集合的区别 容纳元素的区别： 数组：可以存储基本数据类型和引用数据类型。 集合：只能存储引用数据类型（如果存储的是 int 类型，会自动封装为 Integer）。 长度的区别： 数组：长度是固定的，需要提前声明。 集合：长度可变。 List、Set、Queue、Map 的区别 List：存储的元素有序、可重复，可使用下标操作元素； Set：无序、不可重复的集合； Queue：按照特定规则确定先后顺序，存储的元素有序、可重复； Map：使用键值对保存数据，kay无序不可重复，value无序可重复。 ListArrayList扩容机制底层基于动态数组实现，容量也可以动态增长。 手动扩容，需要提前知道数据的大概长度 12ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.ensureCapacity(1000); // 提前扩容到至少 1000 个元素的容量 自动扩容 计算出新的扩容数组的长度后实例化，并将原有数组的内容复制到新数组中去。默认情况下，新的容量是原有容量的1.5倍 怎么在遍历ArrayList时移除一个元素不能使用forEach()遍历，会导致记录修改次数的modCount对不上号，从而报错（快速失败） 123456789101112131415161718192021ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;c&quot;);// 错误示例，异常信息：ConcurrentModificationExceptionlist.forEach(item -&gt; &#123; if (item.equals(&quot;b&quot;)) &#123; list.remove(item); &#125; &#125;);// 正确移除元素，推荐使用迭代器Iterator iterator = list.iterator();while (iterator.hasNext()) &#123; if (iterator.next().equals(&quot;b&quot;)) &#123; iterator.remove(); System.out.println(&quot;b被移除&quot;); &#125;&#125; ArrayList和LinkedList实际开发中很少用到LinkedList，需要用到的场景几乎都可以用ArrayList平替。（需要频繁在首尾两端操作、实现队列&#x2F;双端队列结构时使用LinkedList） 特性 ArrayList LinkedList 底层数据结构 动态数组（Object[]） 双向链表（每个元素包含前后节点的引用） 访问速度 随机访问更快（通过索引直接访问） 访问较慢（需要从头或尾遍历到指定位置） 插入&#x2F;删除性能 插入和删除操作较慢，尤其是在中间位置进行插入&#x2F;删除时（需要移动元素） 在头尾插入&#x2F;删除较快，在中间插入&#x2F;删除时相对较慢（需要遍历链表） 扩容方式 数组扩容（默认1.5倍扩容） 不需要扩容，链表节点动态增加 内存开销 只存储数据本身，占用较少内存 存储每个元素时需要额外存储前后节点的引用，因此内存开销较大 线程安全 不是线程安全的，必须手动同步 不是线程安全的，必须手动同步 适用场景 适合频繁进行随机访问操作，尤其是查询操作较多的场景 适合频繁进行插入和删除操作，尤其是队列操作的场景 关于随机index访问： ArrayList：通过数组下标直接找到元素 LinkedList：需要移动指针遍历，直到找到为止 新增和删除元素，需要根据操作位置判断： ArrayList：可能会扩容和复制数组 LinkedList：只需要修改指针即可 SetComparable 和 Comparator 对比维度 Comparable Comparator 所属包 java.lang java.util 接口方法 int compareTo(Object obj) int compare(Object obj1, Object obj2) 排序逻辑位置 内置于类中（修改原类） 独立于类外（不修改原类） 排序方式 自然排序（类的默认排序规则） 定制排序（灵活定义多种排序规则） 使用场景 类有唯一明确的排序逻辑时（如 String, Date） 需要多种排序方式，或无法修改原类代码时 排序触发方式 Collections.sort(list) Collections.sort(list, comparator) 多条件排序支持 需要手动编写多条件比较逻辑 可通过 thenComparing() 链式调用（Java 8+） 线程安全性 依赖具体实现 依赖具体实现 Java 8+ 增强 无 支持 Lambda 和方法引用（如 Comparator.comparing()） Comparable强制修改原类，耦合较重 1234567891011121314151617181920212223242526272829303132333435363738@Getter@Setterclass Person implements Comparable&lt;Person&gt; &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int compareTo(Person o) &#123; // 升序：this.age - o.age // 降序：o.age - this.age return this.age - o.age; &#125; @Override public String toString() &#123; return name + &quot; (&quot; + age + &quot;)&quot;; &#125;&#125;public static void main(String[] args) &#123; TemporaryTest test = new TemporaryTest(); List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(test.new Person(&quot;name1&quot;, 20)); personList.add(test.new Person(&quot;name2&quot;, 50)); personList.add(test.new Person(&quot;name5&quot;, 1)); System.out.println(&quot;排序前：&quot; + personList); Collections.sort(personList); System.out.println(&quot;排序后：&quot; + personList);&#125; Comparator实现排序逻辑完全解耦，可以定制排序 123456789101112131415161718192021222324252627282930313233343536373839@Getter@Setterclass Person &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return name + &quot; (&quot; + age + &quot;)&quot;; &#125;&#125;public static void main(String[] args) &#123; TemporaryTest test = new TemporaryTest(); List&lt;Person&gt; personList = new ArrayList&lt;&gt;(); personList.add(test.new Person(&quot;Alice&quot;, 20)); personList.add(test.new Person(&quot;Charlie&quot;, 50)); personList.add(test.new Person(&quot;Bob&quot;, 1)); System.out.println(&quot;排序前：&quot; + personList); // Comparator 示例（不修改原类） Comparator&lt;Person&gt; nameComparator = new Comparator&lt;Person&gt;() &#123; public int compare(Person p1, Person p2) &#123; // 外部比较逻辑（按姓名排序） return p1.name.compareTo(p2.name); &#125; &#125;; Collections.sort(personList, nameComparator); System.out.println(&quot;排序后：&quot; + personList);&#125;","tags":["面试","Java集合"],"categories":["面试"]},{"title":"【面试相关】Java基础","path":"/posts/38943.html","content":"面向对象特性 封装 隐藏实现细节，保护数据，将类的内部实现细节隐藏，不允许外部程序直接访问，而是通过该类提供的方法进行操作和访问 继承 从已有类中派生出新的类，新的类继承父类属性和行为，并扩展新的能力，提升代码复用与扩展性 Java是单继承的，也就是一个子类只有一个父类。 多态 同一个行为具有多个不同表现形式的能力（同一接口，不同实现）。 实现多态的三要素：继承、重写、父类引用指向子类对象。 静态多态性 通过重载实现。相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理 动态多态性 在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法 抽象 把客观事物用代码抽象出来 接口和抽象类的异同 共同点 实例化，都不能直接实例化，只能被实现（接口）、继承（抽象类）后，才能创建具体的对象 抽象方法，都可以包含抽象方法，抽象方法没有方法体，必须在子类或实现类钟实现 区别 接口目的：对类的行为进行约束，实现某个接口就有了对应的行为继承和实现： 可以实现或继承多个接口成员变量：必须是 public static final 类型的，不能被修改且必须有初始值方法：从Java8开始，接口中可以定义 default 和 static 方法；从 Java 9 开始，接口中可以定义 private 方法。 抽象类目的：主要用于代码复用，强调所属关系继承和实现： 只能继承一个类（Java不支持多继承）成员变量：成员变量可以使用任何修饰符，也可以在子类中被重新定义或赋值方法：可包含抽象（没有方法体，在子类中实现）和非抽象方法（有具体实现，可在子类中重写） 内部类【重要】深拷贝、浅拷贝、引用拷贝 深拷贝会创建新对象复制基本类型成员复制引用类型对象（类）新对象和原对象在内存上是完全独立的 浅拷贝会创建新对象复制基本类型成员引用类型对象（类）共享引用，数据相互影响新对象和原对象在内存上不是完全独立的， 新对象和原对象的引用类型对象指向内存中的同一个对象 引用拷贝没有创建新的对象，只是创建了一个新的引用， 该引用指向原对象在内存中的地址。如果对其中一个进行修改， 会直接影响到另一个引用。 如果对象内只有基本数据类型，深拷贝和浅拷贝是没有区别的，因为二者都会复制基本数据类型的对象 深浅拷贝的区别在类的 clone() 方法中，深拷贝会对引用类型的成员变量进行拷贝（需要这些成员也实现 Cloneable 接口）。 而浅拷贝则仅复制引用，不复制对象本身。 引用拷贝，就是新对象直接指向了原对象。 深拷贝示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Getter@Setterclass Address implements Cloneable &#123; private String city; public Address(String city) &#123; this.city = city; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;@Getter@Setterclass Person implements Cloneable &#123; private String name; private int age; private Address address; public Person(String name, int age, Address address) &#123; this.name = name; this.age = age; this.address = address; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Person clone = (Person) super.clone(); // 对引用类型进行深拷贝 clone.address = (Address) address.clone(); return clone; &#125;&#125;public class TemporaryTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; // 创建原对象 Person originalPerson = new Person(&quot;Alice&quot;, 30, new Address(&quot;北京&quot;)); // 进行浅拷贝 Person shallowCopyPerson = (Person) originalPerson.clone(); // 修改浅拷贝对象的属性 shallowCopyPerson.setName(&quot;Bob&quot;); shallowCopyPerson.setAge(25); shallowCopyPerson.getAddress().setCity(&quot;上海&quot;); // 先获取拷贝后对象的属性，再对其修改 // 输出原对象和浅拷贝对象的属性（可以看到，原对象的引用数据类型没有变化） System.out.println(&quot;原对象: &quot; + originalPerson.getName() + &quot;, &quot; + originalPerson.getAge() + &quot;, &quot; + originalPerson.getAddress().getCity()); System.out.println(&quot;浅拷贝对象: &quot; + shallowCopyPerson.getName() + &quot;, &quot; + shallowCopyPerson.getAge() + &quot;, &quot; + shallowCopyPerson.getAddress().getCity()); &#125;&#125; 浅拷贝示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Getter@Setterclass Address&#123; private String city; public Address(String city) &#123; this.city = city; &#125;&#125;@Getter@Setterclass Person implements Cloneable &#123; private String name; private int age; private Address address; public Person(String name, int age, Address address) &#123; this.name = name; this.age = age; this.address = address; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;public class TemporaryTest &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; // 创建原对象 Person originalPerson = new Person(&quot;Alice&quot;, 30, new Address(&quot;北京&quot;)); // 进行浅拷贝 Person shallowCopyPerson = (Person) originalPerson.clone(); // 修改浅拷贝对象的属性 shallowCopyPerson.setName(&quot;Bob&quot;); shallowCopyPerson.setAge(25); shallowCopyPerson.getAddress().setCity(&quot;上海&quot;); // 先获取拷贝后对象的属性，再对其修改 // 输出原对象和浅拷贝对象的属性（可以看到，原对象的引用数据类型也发生了变化） System.out.println(&quot;原对象: &quot; + originalPerson.getName() + &quot;, &quot; + originalPerson.getAge() + &quot;, &quot; + originalPerson.getAddress().getCity()); System.out.println(&quot;浅拷贝对象: &quot; + shallowCopyPerson.getName() + &quot;, &quot; + shallowCopyPerson.getAge() + &quot;, &quot; + shallowCopyPerson.getAddress().getCity()); &#125;&#125; 引用拷贝示例 1234567891011121314151617181920212223class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;public class TemporaryTest &#123; public static void main(String[] args) &#123; Point p1 = new Point(1, 2); Point p2 = p1; // 修改新拷贝中的值 p2.x = 3; System.out.println(p1.x); // 3 &#125;&#125; Object一个特殊的类，是所有类的父类。 常用方法 hashCode()，返回对象的哈希码。将与对象相关的信息映射成一个哈希值，默认的实现是根据内存地址换算的 toString()，默认输出对象地址，推荐重写以输出对象的值 equals(Object obj)，比较两个对象的内存地址是否相等 clone()，创建并返回当前对象的一份拷贝（需要实现Cloneable接口） wait()，根据入参暂停线程的执行 getClass()，返回此Object的运行时类，常用于反射机制 &#x3D;&#x3D;和equals的区别 &#x3D;&#x3D;对于基本数据类型，比较的是他们的值是否相等对于引用数据类型，比较对象的内存地址（引用），即是否指向同一个对象 equals常用于比较引用数据类型的内容，即是否具有相同的属性值默认实现和==类似，即比较对象的内存地址 示例123456// String的equals()方法已经被重写过String a = new String(&quot;hello&quot;);String b = new String(&quot;hello&quot;);System.out.println(a == b); // false, 因为引用不同System.out.println(a.equals(b)); // true, 因为内容相同 hashCode()有什么用 用于返回哈希码，作用是确定该对象在哈希表中的位置 在使用哈希算法进行对象查找时，可快速定位对象，提高查询效率 总结 如果两个对象通过equals()比较为相同，那么它们的hashCode也相同两个对象的hashCode相同， 两个对象的equals()不一定相同（可能发生哈希碰撞） 如果hashCode不相同，就可以直接认为这两个对象不相等 重写equals()时，也必须重写hashCode()，否则会出现用hashCode()判断是相等的两个对象，hashCode()缺不相等 StringString、StringBuffer、StringBuilder String 是否可变：不可变 线程安全：是 性能：较低（每次修改都会创建新对象） 适用场景：适用于不频繁修改的场景 内存使用：内存占用较大 常用方法：concat() , replace(), substring() StringBuffer 是否可变：可变 线程安全：是（通过同步） 性能：较高（支持高效的修改操作） 适用场景：适用于多线程环境，频繁修改时使用 内存使用：内存占用较小 常用方法：append(), insert(), delete(), reverse() StringBuilder 是否可变：可变 线程安全：否（不通过同步） 性能：较高（支持高效的修改操作） 适用场景：适用于单线程环境，频繁修改时使用 内存使用：内存占用较小 常用方法：append(), insert(), delete(), reverse() 对于三者的使用总结 操作少量数据，可以使用：String 单线程情况下，操作大量数据，使用：StringBuilder多线程情况下，操作大量数据，使用：StringBuffer String为什么不可变？ String类本身是final的，不能被继承，进而避免子类破坏String不可变 1public final class String 存储字符串的数组使用final修饰，并且是私有的（private） 12/** The value is used for character storage. */private final char value[]; String类没有类似setter的方法，内容不能被直接修改 new String(“ss”) 创建了几个对象？1String str = new String(&quot;ss&quot;); 答案：会创建一个或者两个对象 如果字符串常量池中已经存在了ss，则只会创建一个str对象 如果字符串常量池中不存在，则会在字符串常量池中创建一个ss对象，并且再创建一个str对象 字符串常量池针对String类专门开辟的区域，主要为了避免字符串重复创建。 底层实现为什么从char换成byte是从JDK 9开始的，底层实现从 char[] ，换成了 byte[] ： 减少内存占用：char在内存中占2字节，byte占1字节，相当于压缩了数据 新增byte类型的coder字段，记录当前字符串的编码格式： 0：LATIN-1（单字节） 1：UTF-16（双字节） 字符串拼接 方式 优点 缺点 适用场景 + 简单直观，代码易读 大量拼接时效率低 少量拼接，代码简洁为主 StringBuilder 高效，适合频繁拼接 线程不安全 大量拼接，性能要求较高 StringBuffer 高效，线程安全 较 StringBuilder 慢 多线程拼接，线程安全为主 自增自减运算符符号在前就先加&#x2F;减，符号在后就后加&#x2F;减。 前缀形式（++a、–a），先自增&#x2F;自减，然后再赋值或使用该变量 后缀形式（a++、a–），先赋值或使用该变量，然后再执行自增&#x2F;自减 各变量的值分别是多少答案12345int a = 9;int b = a++;int c = ++a;int d = c--;int e = --d;答案：a &#x3D; 11，b &#x3D; 9，c &#x3D; 10， d &#x3D; 10，e &#x3D; 10，过程如下：a &#x3D; 9， 初始值为9b &#x3D; a++， 先赋值给 b &#x3D; 9，再自增 a &#x3D; 10c &#x3D; ++a， 先自增再赋值，此时 a &#x3D; 10，所以 a &#x3D; 11，此时 c &#x3D; 11（c还有一次运算）d &#x3D; c–， 先赋值再自减，此时 d &#x3D; 11（d还有一次运算），c &#x3D; 10e &#x3D; –d， 先自减再赋值，此时 d &#x3D; 10，e &#x3D; 10 基本数据类型和包装数据类型 类型名称 类型 位数 字节数 默认值 取值范围 整数型 byte 8 1 0 -128 至 127 整数型 short 16 2 0 -32768（-2^15） 至 32767（2^15 - 1） 整数型 int 32 4 0 -2147483648 至 2147483647 整数型 long 64 8 0L -9223372036854775808（-2^63） 至 9223372036854775807（2^63 -1） 单精度浮点 float 32 4 0.0f ±3.40282347E+38F （有效数字 6-7 位） 双精度浮点 double 64 8 0.0d ±1.79769313486231570E+308 （有效数字 15 位） 字符型 char 16 2 ‘\\u0000’ 0 ~ 65535（2^16 - 1） 布尔型 boolean 1 false true 或 false 区别 用途： 方法参数、对象属性等常使用包装类型，并且可用于泛型，基本类型则很少用于这些地方。 存储： 基本数据类型局部变量在栈中局部变量表， 未被 static 修饰的成员变量在虚拟机的堆中； 包装类型属于对象类型，存放于堆中。 基本数据类型存放在栈中是一个常见的误区如果它们是局部变量，那么它们会存放在栈中； 如果它们是成员变量，那么它们会存放在堆&#x2F;方法区&#x2F;元空间中。 空间： 基本数据类型比包装类型占用空间小。 默认值： 成员变量包装类型默认 null，基本类型有非 null 默认值。 比较： 基本类型使用 &#x3D;&#x3D; 比值，包装类型 &#x3D;&#x3D; 比内存地址。 所有整型包装类对象之间值的比较，用 equals() 方法。 包装类型的缓存机制 整数型（Byte，Short，Integer，Long） 这四种都默认创建了数值[-128, 127]]的相应类型缓存数据 字符型（Character） 默认创建了数值[0, 127]]的相应类型缓存数据 布尔型（Boolean） 缓存了True、False两种 浮点型（Float，Double） 和其他类型不同，没有缓存机制 自动拆装箱 装箱：将基本类型用其对应的包装类型（实际上调用了包装类的 valueOf() 方法） 拆箱：将包装类型转换为基本数据类型（调用了xxxValue()方法） 频繁拆装箱会影响性能，应尽量避免不必要的操作 示例12345678Integer i = 10; // 装箱// 等价于Integer i = Integer.valueOf(10)int n = i; // 拆箱// 等价于int n = i.intValue() 浮点数运算精度丢失示例12345float a = 2.0f - 1.9f;float b = 1.8f - 1.7f;System.out.println(a + &quot; &quot; + b); // 0.100000024 0.099999905System.out.println(a == b); // false 原因： 二进制表示：十进制小数转化为二进制时，有些小数无法精确表示，还有的会出现无限循环小数，由于浮点型的尾数部分有限，所以只能截取一部分存储，造成精度丢失 十进制的0.1，转为二进制就是无限循环小数0.00011001100110011… 运算过程的舍入：由于存储位数限制，在存储运算的中间结果和最终结果时，会对二进制数进行舍入，同样会导致精度丢失 解决方法：使用 BigDecimal 使用BigDecimal时，禁止使用构造方法（new BigDecimal(double)），否则会造成精度丢失。 应该使用：new BigDecimal(String val)、BigDecimal.valueOf(double val) 比较大小时应使用compareTo()方法，因为equals()方法除了比较大小还会比较精度： 123BigDecimal a = new BigDecimal(&quot;1&quot;);BigDecimal b = new BigDecimal(&quot;1.0&quot;);System.out.println(a.equals(b)); // false 方法为什么静态方法不能调用非静态成员 静态方法 属于类，而不属于类的实例，类加载时就会分配到内存中 可以通过类名直接调用 不能直接访问非静态成员（非静态变量、方法） 非静态成员 属于类的实例，创建了类的对象后才会分配内存空间 包括非静态变量、方法，是和对象绑定的 总结 静态方法属于类，类加载时就会分配内存，可通过类名直接访问； 非静态成员属于实例对象，对象实例化后才存在，需要通过类的实例对象访问。 重载和重写 方法重载 在同个类中多个方法可以有相同的方法名称，必须有不同的参数列表 12345void setPersonInfo()&#123;&#125;void setPersonInfo(String name)&#123;&#125;void setPersonInfo(String name, int age)&#123;&#125; 方法重写 针对的是父类和子类之间的，父类功能无法满足子类需求时，可以在子类中对父类方法进行重写。 方法重写时，方法名和形参列表必须一致 123456789101112class Animal &#123; public void makeSound() &#123; System.out.println(&quot;动物&quot;); &#125;&#125;class Dog extends Animal &#123; @Override public void makeSound() &#123; System.out.println(&quot;狗&quot;); &#125;&#125; 可变长参数可变长参数就是允许在调用方法时传入长度不定的参数，同时，可变参数只能作为函数的最后一个参数，例如： 示例1234567public static void method(String... args)&#123; &#125;public static void method(String arg, String... args)&#123; &#125; 如果遇到方法重载的情况时，优先匹配固定参数的方法，因为固定参数的方法匹配度更高 Java为什么只有值传递首先要明确实参和形参的概念： 实参实际参数，用于传递给函数、方法的参数，必须要有确定的值 形参形式参数，用于定义函数、方法，不需要有确定的值 示例123456789String str = &quot;hello&quot;;// 此处的str为实参sayHello(str);// 此处的arg为形参void sayHello(String arg)&#123; System.out.println(arg);&#125; 值传递和引用传递程序中奖实参传递给方法、函数的方式有两种： 值传递：方法接收的是实参值的拷贝，会创建副本 引用传递：方法接收的是实参在堆中的地址，不会创建副本，对形参的修改会影响到实参 Java中只有值传递 案例一：传递基本类型 swap()方法中arg1、arg2的值，都是从num1、num2复制过来的，修改副本不会影响到原参数。 传递基本类型123456789101112131415161718public static void main(String[] args) &#123; int num1 = 1; int num2 = 2; swap(num1, num2); System.out.println(&quot;方法执行后，num1：&quot; + num1); // num1 = 1 System.out.println(&quot;方法执行后，num2：&quot; + num2); // num2 = 2&#125;static void swap(int arg1, int arg2) &#123; int temp = arg1; arg1 = arg2; arg2 = temp; System.out.println(&quot;swap方法内，arg1：&quot; + arg1); // arg1 = 2 System.out.println(&quot;swap方法内，arg2：&quot; + arg2); // arg2 = 1&#125; 案例二：传递引用类型1（数组） 这个案例中，形参传递的还是值，不过值是实参的地址，和arr[]指向的是同一个数组对象 传递引用类型1（数组）123456789101112131415public static void main(String[] args) &#123; int arr[] = &#123;1,2,3,4&#125;; System.out.println(&quot;方法执行前，arr[0]：&quot; + arr[0]); setArrFirstValue(arr); System.out.println(&quot;方法执行后，arr[0]：&quot; + arr[0]);&#125;static void setArrFirstValue(int[] arg) &#123; arg[0] = 0; System.out.println(&quot;方法内，arg[0]：&quot; + arg[0]);&#125; 案例三：传递引用类型2（对象） 参数p1、p2拷贝的只是zhang、wang的地址，因此swap()方法内的互换也只是两个地址的互换，不会影响到实参zhang、wang。 传递引用类型2（对象）1234567891011121314151617181920212223@Setter@Getter@AllArgsConstructorpublic static class Person &#123; private String name;&#125;public static void swap(Person p1, Person p2) &#123; Person temp = p1; p1 = p2; p2 = temp; System.out.println(&quot;方法内，p1（传入zhang）：&quot; + p1.name); // wang System.out.println(&quot;方法内，p2（传入wang）：&quot; + p2.name); // zhang&#125;public static void main(String[] args) &#123; Person zhang = new Person(&quot;张&quot;); Person wang = new Person(&quot;王&quot;); swap(zhang, wang); System.out.println(&quot;方法执行后，zhang：&quot; + zhang.name); // zhang System.out.println(&quot;方法执行后，wang：&quot; + wang.name); // wang&#125; 异常 概述Throwable是所有异常的父类，有两个直接子类：Exception、Error ExceptionChecked Exception（已检查异常）必须在代码中手动处理（使用try-catch或throws声明），常见例子：IOExceptionSQLExceptionClassNotFoundExceptionUnchecked Exception（未检查异常）继承自RuntimeException，可以选择处理或不处理，常见例子：NullPointerExceptionArrayIndexOutOfBoundsExceptionIllegalArgumentException Error程序无法处理的错误，通常是JVM层面的问题不建议捕获或处理（可以捕获，但是Java设计理念中，不应尝试通过代码处理Error），常见例子：IOErrorOutOfMenmoryErrorAssertionError try-with-resources 和 try-catch-finally try-with-resources实现了 AutoCloseable 或 Closeable 接口自动关闭 try 中声明的资源，无需手动调用 close() try-catch-finally需要在 finally 中手动调用 close()如果在 finally 中关闭资源时抛出异常，可能会覆盖掉原有异常 注意事项 如果 try 和 finally 块中都有 return 语句，finally 块仍然会执行。 但如果 finally 块中也包含 return 语句，则 try 块中的 return 值会被 finally 块中的 return 覆盖。 1234567891011public static int testTryAndFinally()&#123; try &#123; return 1; &#125; finally &#123; return 2; &#125;&#125;public static void main(String[] args) &#123; System.out.println(testTryAndFinally()); // 2&#125; throw 和 throws 关键字 作用 指定的内容 出现位置 支持的异常数量 throws 声明方法可能抛出的异常 异常类型名称 方法定义的括号后 可以声明多个异常，使用逗号分隔 throw 显式抛出一个异常对象 异常实例 方法体内部 一次只能抛出一个异常 出现位置1234567// throws 出现在方法签名中public void readFile(String filePath) throws IOException &#123; if (filePath == null || filePath.isEmpty()) &#123; // throw 出现在方法体内 throw new IOException(&quot;文件路径不能为空&quot;); &#125;&#125; 泛型参数化类型机制，允许类、接口、方法能够操作不同类型的对象。 主要目的是提高代码的类型安全性和可读性。 作用 类型安全，编译时检查类型错误，避免运行时报错 代码复用，可以支持多种数据类型的通用代码 可读性和可维护性，明确指定类型，减少模糊的类型操作 常用的参数命名T：Type，表示任意类型，常用于通用类或者方法 1public class Box&lt;T&gt;&#123;&#125;E：Element，多用于集合类型 1List interface List&lt;E&gt; &#123;&#125;K、V：Key、Value，用于键值对映射 1public interface Map&lt;K, V&gt; &#123;&#125;N： Number，多用于操作数字的情况 1public class Calculator&lt;N extends Number&gt; &#123;&#125;?：用于不确定的类型 1public void printList(List&lt;?&gt; list) &#123;&#125;R：Result，表示返回值类型（不常用） 1234567public interface Converter&lt;T, R&gt; &#123; // T 表示输入类型，R 表示返回类型 R convert(T input);&#125;Converter&lt;String, Integer&gt; converter = Integer::parseInt; // String 转换为 Integerint result = converter.convert(&quot;123&quot;);System.out.println(result); // 输出: 123 擦除机制擦除就是在编译时，把所有泛型信息删除或者替换为它的上界， 从而使运行时候只能看到原始类型，编译时依然可以保证类型安全。 以下代码可以看出，编译后的泛型参数T被替换为它的上界（如果没有指定，默认为Object） 编译前1234567891011public class Box&lt;T&gt; &#123; private T item; public void set(T item) &#123; this.item = item; &#125; public T get() &#123; return item; &#125;&#125; 编译后的字节码1234567891011public class Box &#123; private Object item; public void set(Object item) &#123; this.item = item; &#125; public Object get() &#123; return item; &#125;&#125; 类型边界用于限制泛型参数可以接收的类型范围， 如果希望传入的类型必须实现某个接口或者继承自某个类时，可以使用 extends 设置上界 示例代码12345678910public &lt;T extends Comparable&lt;T&gt;&gt; T findMax(List&lt;T&gt; list) &#123; T max = list.get(0); for (T item : list) &#123; // 由于 T 受限于 Comparable&lt;T&gt;，可以安全地调用 compareTo 方法 if (item.compareTo(max) &gt; 0) &#123; max = item; &#125; &#125; return max;&#125; 方法重载时的局限由于泛型在编译的时候会被擦除（泛型参数被替换为其上界，默认是Object），所以在运行时不同的泛型参数之间的信息会丢失。 123456// 假设写了下面两个方法public void process(List&lt;Integer&gt; list) &#123; ... &#125;public void process(List&lt;String&gt; list) &#123; ... &#125;// 编译器编译后的代码public void process(List list) &#123; ... &#125; 这样会导致两个方法签名完全相同，编译器会报重载冲突错误。 方法签名由方法名称和参数列表（参数类型和顺序）组成，编译器判断两个方法是否重载时，只会比较名称和参数类型 解决方法：PECS原则 当一个泛型容器用于读取数据时，它就是生产者，使用上界通配符：extends，&lt;? extends T&gt; 示例代码12345678910111213141516171819202122232425/** * 计算入参的和，要求入参类型为Number类型或其子类 * * 从集合中读取数据，确保每个元素都是Number或其Number子类。 * 生产者模式，只负责提供数据，不允许添加新的数据。 * @param numbers * @return */public static double sumNumbers(List&lt;? extends Number&gt; numbers) &#123; double sum = 0; for (Number num : numbers) &#123; // 这里可以安全地调用 Number 的方法，比如 doubleValue() sum += num.doubleValue(); &#125; return sum;&#125;public static void main(String[] args) &#123; // 调用示例： List&lt;Integer&gt; intList = Arrays.asList(1, 2, 3); double total = sumNumbers(intList); // 输出结果：应该输出 6.0 System.out.println(&quot;Sum: &quot; + total);&#125; 当一个泛型容器用于写入数据时，它就是消费者，使用下界通配符：super，&lt;? super T&gt; 示例代码123456789101112131415161718192021222324252627282930/** * 计算入参的和，要求入参类型为Integer或其父类 * * 从集合中读取数据，要求是Integer或其父类（Number下的其他类型也可写入） * 消费者模式，允许写入Integer或Number下的其他子类，但是读取时只能为Object * @param list * @return*/public static int addAndSumNumbers(List&lt;? super Integer&gt; list) &#123; // 读取数据：由于参数类型是 &lt;? super Integer&gt;，编译器只能将读取的数据视为 Object // 因此这里需要进行类型检查，并将能转换为 Number 的对象取出其数值参与求和 int sum = 0; for (Object obj : list) &#123; if (obj instanceof Number) &#123; sum += ((Number) obj).intValue(); &#125; &#125; return sum;&#125;public static void main(String[] args) &#123; // 调用示例 List&lt;Number&gt; numberList = new ArrayList&lt;&gt;(); numberList.add(100); numberList.add(200); int total = addAndSumNumbers(numberList); // 输出结果：应该输出 300（100 + 200） System.out.println(&quot;Total sum: &quot; + total);&#125; 反射通过反射可以获取并调用任意一个类的所有属性和方法。 优点代码更加灵活，在运行时动态获取和操作类的成员为框架和工具类开发提供便利 缺点有性能影响，需要检查类型和安全性安全风险，可能绕过访问权限（private）难阅读和维护 常见使用场景框架开发： 例如Spring、Mybatis等，使用反射来实现动态代理、依赖注入、AOP等功能工具类： 一些通用工具可能会用到：序列化（将对象转为JSON或XML）、日志工具（通过反射打印对象属性）动态代理： 在需要拦截权限的场景中使用：权限校验、日志记录等（可以直接使用框架提供的功能，Spring的AOP）测试： 单元测试中通过反射访问私有字段和方法，方便测试无法直接访问的内部逻辑 实际开发中，由于性能可可读性问题，通常采用其他方法代替： 直接调用 设计模式（工厂模式、策略模式等） 框架功能（Spring AOP、依赖注入等） 注解本质是一个继承了Annotation的特殊接口。 序列化和反序列化 序列化：将数据结构或对象，转换为可以存储或传输的形式（二进制字节流、JSON、XML等） 反序列化：将序列化后的数据，转换为原始数据结构或对象的过程 常见应用场景：远程方法调用RPC之前，需要先序列化，对方接收到序列化的对象后，再反序列化存储到文件、数据库前需要序列化，从文件或数据库中读取对象时需要反序列化 SerializableJDK自带的序列化方式，在参与交互的对象中，一般要求手动指定序列化号：serialVersionUID。 如果不手动指定，编译器会动态生成默认的serialVersionUID。 SerializableUID的序列化处理通常被static修饰的不会被序列化，而SerializableUID是一个特例： 序列化时被写进二进制流； 反序列化时会对其解析并做一致性判断，以此来验证序列化对象的版本一致性，如果不匹配，反序列化时会抛出异常。 I&#x2F;O 概述所有IO流都是从下面四个抽象基类中派生的： InputStream&#x2F;Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流 OutputStream&#x2F;Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流 主要分为字节流和字符流： 特点 字节流 字符流 单位 字节（8 bits） 字符（16 bits，基于编码） 常用类 FileInputStream，FileOutputStream FileReader，FileWriter 编码问题 不处理编码，按字节读取 自动编码解码 适用场景 二进制数据处理（图片、视频等） 文本数据处理（文件、字符串） 缓冲流提高IO效率，减少物理磁盘操作次数。 字节缓冲流：BufferedInputStream、BufferedOutputStream 字符缓冲流：BufferedReader、BufferedWriter NIO特点引入非阻塞IO和多路复用机制，减少线程阻塞，提高并发能力，适合高性能网络编程，有三个核心： Channel：数据传输通道，常用的有FileChannel、SocketChannel Buffer：数据容器，用于读写操作 Selector：多路复用起，用于管理多个Channel 文件读写示例12345678910try (FileChannel fileChannel = new FileInputStream(&quot;input.txt&quot;).getChannel()) &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); while (fileChannel.read(buffer) &gt; 0) &#123; buffer.flip(); while (buffer.hasRemaining()) &#123; System.out.print((char) buffer.get()); &#125; buffer.clear(); &#125;&#125; Lambda表达式由三部分组成：参数、箭头（-&gt;）、表达式，使用示例： 如果无法放在一个表达式中，需要用大括号 &#123;&#125; 包裹： 123456789(String first, String second) -&gt;&#123; if (first.length() &lt; second.length()) &#123; return -1; &#125; else if (first.length() &gt; second.length()) &#123; return 1; &#125; else &#123; return 0; &#125;&#125; 如果没有参数，仍需提供括号： 12345() -&gt; &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(i); &#125;&#125; 如果知道参数的类型，可以不用写参数类型： 123String[] planets = new String[]&#123;&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;&#125;;Arrays.sort(planets, (first, second) -&gt; first.length() - second.length()); 不允许在某个分支返回值，其他分支不返回： 1(int x) -&gt; &#123; if (x &gt;= 0) return 1; &#125; 总结 特性 示例 说明 基本语法 (a, b) -&gt; a + b 省略 return 省略参数类型 (x, y) -&gt; x * y 编译器自动推断 单个参数省略括号 x -&gt; x * 2 只有一个参数可省略 () 省略 &#123;&#125; (a, b) -&gt; a + b 只有一行代码时可省略 &#123;&#125; 作为匿名类替代 Runnable r = () -&gt; System.out.println(&quot;Run!&quot;); 代码更简洁 Stream API .filter(x -&gt; x &gt; 5).map(String::toUpperCase).collect(...) 操作集合更简洁 方法引用 list.forEach(System.out::println); Lambda 的简化","tags":["面试","Java基础"],"categories":["面试"]},{"title":"Hexo搭建静态博客流程","path":"/posts/51860.html","content":"其他配置使用CloudFlare配置博客搭建（一）| 利用cloudflare加速github博客访问https://qinyu.space/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%88%A9%E7%94%A8cloudflare%E5%8A%A0%E9%80%9Fgithub%E4%B8%BB%E9%A1%B5%E8%AE%BF%E9%97%AE/ 如何给你的网站套上Cloudflare（以阿里云为例）https://blog.csdn.net/zhyl8157121/article/details/100551592 需要在阿里云上修改DNS服务器 如果提示：重定向次数过多需要在cloudflare中修改 SSL&#x2F;TLS，点击配置、自定义、选择完全并保存。 个性化配置左侧边栏背景色设置 打开主题的css文件进行修改： node_modules/hexo-theme-stellar/source/css/_defines/theme.styl1234567_light_root()...--alpha60: hsl($color-background-h, $color-background-s, $color-background-l)_dark_root()...--alpha60: hsl($color-background-h, $color-background-s * 0.5, (100 - $color-background-l) * 2 + 8) 需要修改两个节点下的 –alpha60 属性，要和 –site-bg 的值一致 左侧边栏主导航栏配置修改方式https://github.com/weekdaycare/hexo-theme-stellar/blob/main/source/css/_components/sidebar/menu.styl 新建 menu.styl 文件，路径： node_modules/hexo-theme-stellar/source/css/_components/sidebar/menu.styl 文件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556.nav-area .menudisplay: gridmargin-bottom: 8pxbox-shadow: $boxshadow-inset-blockpadding: 1pxborder: 1px solid var(--block-border)border-radius: $border-barbackground: var(--block)grid-template-columns: repeat(hexo-config(&#x27;menubar.columns&#x27;), 1fr)grid-gap: 2px&amp;::-webkit-scrollbardisplay: none&amp;::-webkit-scrollbar-track-piecebackground: transparent&amp;::-webkit-scrollbar-thumbdisplay: none.nav-itembox-sizing: border-boxwidth: 100%min-height: 38pxfont-size: $fs-15font-weight: 500color: var(--text-p3)text-align: centerposition: relativedisplay: flexflex-direction: columnalign-items: centerjustify-content: centerimg,svgheight: 28pxobject-fit: containfilter: grayscale(100%) brightness(0.8) opacity(0.8)trans1 allspantext-overflow: ellipsisword-break: keep-all&amp;.active, &amp;:hovercolor: var(--text-p1)background: var(--card)trans1 backgroundborder-radius: $border-barbox-shadow: $boxshadow-buttonimg,svgfilter: unset&amp;.active:aftercontent: &#x27;&#x27;position absolutewidth: 16pxheight: 2pxleft: 50%transform: translateX(-50%)border-radius: 2pxbottom: 2pxbackground: currentColor 左侧边栏主导航栏按钮配置 修改或新建 _config.stellar.yml 中 menubar 节点下的内容：_config.stellar.yml123456789101112131415161718menubar: columns: 3 # 一行多少个 items: # 可按照自己需求增加，符合以下格式即可 - id: post theme: &#x27;#1BCDFC&#x27; icon: # solar:documents-bold-duotone title: 博客 url: / - id: shuoshuo theme: &#x27;#3DC550&#x27; icon: # solar:notebook-bookmark-bold-duotone title: 时间线 url: /shuoshuo/ - id: about theme: &#x27;#FA6400&#x27; icon: # solar:planet-bold-duotone title: 关于 url: /about/ 在 source 文件夹下创建与配置文件中 menubar.items.id&#x2F;url 同名的文件夹，并创建 index.md 文件，内容如下：source/about/index.md12345---menu_id: abouttitle: 关于comments: false--- 给超长代码添加滚动条给超长代码添加滚动条https://felicxfoster.github.io/4199909915.html#%E7%BB%99%E8%B6%85%E9%95%BF%E4%BB%A3%E7%A0%81%E5%9D%97%E5%A2%9E%E5%8A%A0%E6%BB%9A%E5%8A%A8%E6%9D%A1 新建 custom.js 文件路径：在node_modules/hexo-theme-stellar/source/js 1234567891011121314151617181920// 给超长代码块增加滚动条function adjustCodeBlockHeight() &#123; document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123; // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll(&#x27;.md-text&#x27;); // 遍历每个.md-text元素 codeBlocks.forEach(function (block) &#123; // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll(&#x27;.highlight&#x27;); highlightBlocks.forEach(function (highlightBlock) &#123; if (highlightBlock.clientHeight &gt; 800) &#123; highlightBlock.style.maxHeight = &#x27;300px&#x27;; highlightBlock.style.overflow = &#x27;auto&#x27;; &#125; &#125;); &#125;); &#125;);&#125;adjustCodeBlockHeight() 在 _config.yml 文件的最后一行添加以下信息 12345inject: script: # 自定义js - &lt;script type=&quot;text/javascript&quot; src=&quot;/js/custom.js?1&quot;&gt;&lt;/script&gt; - &lt;script src=&quot;/js/custom.js?1&quot;&gt;&lt;/script&gt; 文章页面包屑添加信息文章页面包屑添加显示信息https://blog.felicx.eu.org/4199909915.html#%E6%96%87%E7%AB%A0%E9%9D%A2%E5%8C%85%E5%B1%91%E6%98%BE%E7%A4%BA%E5%AD%97%E6%95%B0-%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF-%E6%A0%87%E7%AD%BE 在 article_banner.ejs 内添加内容，路径：node_modules/hexo-theme-stellar/layout/_partial/main/navbar/123456789101112131415161718// 3.left.bottomel += partial(&#x27;dateinfo&#x27;)// 新增内容如下：//新增：字数显示|阅读时长显示el += &#x27;&lt;div class=&quot;flex-row&quot; id=&quot;page-words&quot;&gt;&lt;span style=&quot;padding: 4px;&quot;&gt;本文：&#x27; + wordcount(page.content) + &#x27;字&lt;/span&gt;&lt;span class=&quot;sep updated&quot; style=&quot;padding: 4px;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;text updated&quot; style=&quot;padding: 4px;&quot;&gt;阅读时长：&#x27; + min2read(page.content) + &#x27;分&lt;/span&gt;&lt;/div&gt;&#x27;;//新增：标签显示if (page.layout == &quot;post&quot; &amp;&amp; page.tags &amp;&amp; page.tags.length &gt; 0) &#123;el += &#x27;&lt;div class=&quot;flex-row&quot; id=&quot;tag&quot;&gt;&#x27;; // 将标签容器的创建移动到条件内部el += &#x27; &lt;span&gt;&amp;nbsp标签：&lt;/span&gt;&#x27;;el += list_categories(page.tags, &#123;class: &quot;cap breadcrumb&quot;,show_count: false,separator: &#x27;&amp;nbsp; &#x27;,style: &quot;none&quot;&#125;);el += &#x27;&amp;nbsp&lt;/div&gt;&#x27;;&#125; 在 _custom.styl 内的最后添加内容，路径：node_modules/hexo-theme-stellar/source/css/12345678910/* 文章内字数统计&amp;阅读时长 */.bread-nav div#page-words span.sep:before &#123;content: &#x27;|&#x27;;&#125;.bread-nav div#page-words span.updated &#123;visibility: visible;&#125;.bread-nav:hover div#page-words span.updated &#123;visibility: visible;&#125; 在 bread-nav.styl 中修改内容，将hidden修改为visible，路径：node_modules/hexo-theme-stellar/source/css/_components/partial/12345div#post-meta span.sep:before content: &#x27;|&#x27; span.updated visibility: visible 常用写作组件quot 引用Stellar 是迄今为止最好用的主题 1&#123;% quot Stellar 是迄今为止最好用的主题 %&#125; 热门话题 1&#123;% quot 热门话题 icon:hashtag %&#125; 特别引用 1&#123;% quot 特别引用 icon:default %&#125; copy 复制行 1&#123;% copy curl -s https://sh.xaox.cc/install | sh %&#125; $ 1&#123;% copy curl -s https://sh.xaox.cc/install | sh prefix:$ %&#125; 1&#123;% copy git:https xaoxuu.com/hexo-theme-stellar %&#125; box 盒子容器此处为代码块格式，如果需要普通盒子容器，去掉 child:codeblock 即可： test123func test() &#123; // ...&#125; 语法123&#123;% box child:codeblock color:green %&#125; 内容&#123;% endbox %&#125; 普通格式的盒子容器： 内容 语法123&#123;% box color:green %&#125; 内容&#123;% endbox %&#125; 代码块代码块左上角为文件名或文件路径： Application.java12345public class App &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 语法1234``` 语言 文件名或路径 代码```（此处为占位符需要删除） tabs 分栏容器active：默认显示的标签页，默认为1 align:center：设置默认居中对齐（设置后，box容器按照内容显示大小） box容器代码块内容12let x = 123print(&quot;hello world&quot;) 语法12345678910111213&#123;% tabs active:1 align:center %&#125;&lt;!-- tab 标签页1名称--&gt;&#123;% box %&#125;内容&#123;% endbox %&#125;&lt;!-- tab 标签页2名称--&gt;&#123;% box %&#125;内容&#123;% endbox %&#125;&#123;% endtabs %&#125; grid 网格容器默认为动态列数，即每格最小宽度为240px，页面大于480px会显示2列，大于720px会显示3列，以此类推。 如果在网格内使用box容器，需要注意调整格式 工作为什么不喜欢工作也能很好的完成？工作是别人为你设计好的系统，像是在传送带上。同事、老板会不断推着你向前。 自我目标自发想去做的为什么会拖延？理论上内在动机更足，例如：学习、考证、副业等。但是这些没有人管你要结果，也没有deadline，把自己从舒服的状态抓出来做这件事是很累的，身体会默认选择让自己产生多巴胺的行为。 语法12345678910111213&#123;% grid %&#125;&lt;!-- cell --&gt;**标题**&#123;% box child:codeblock color:green %&#125;内容&#123;% endbox %&#125;&lt;!-- cell --&gt;**标题**&#123;% box child:codeblock color:red %&#125;内容&#123;% endbox %&#125;&#123;% endgrid %&#125; note 备注块、标题备注块、彩色备注块部分颜色：red、orange、amber、yellow、green、cyan、blue、purple 常用：light、dark、warning、error 正文 1&#123;% note color:warning 正文 %&#125; 标题正文 1&#123;% note color:cyan 标题 正文 %&#125; 文本修饰标签 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 12345678- 这是 &#123;% psw 密码 %&#125; 标签- 这是 &#123;% u 下划线 %&#125; 标签- 这是 &#123;% emp 着重号 %&#125; 标签- 这是 &#123;% wavy 波浪线 %&#125; 标签- 这是 &#123;% del 删除线 %&#125; 标签- 这是 &#123;% sup 上角标 color:red %&#125; 标签- 这是 &#123;% sub 下角标 %&#125; 标签- 这是 &#123;% kbd 键盘样式 %&#125; 标签，试一试：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125;","tags":["Hexo"],"categories":["其他"]},{"title":"敏捷开发流程","path":"/posts/51728.html","content":"需求整理概述 生活中的问题→需求 解决问题的方式（APP、小程序等）→愿景 达到的效果→心动念 需求管理将需求细化，明确应用的功能，整理为需求库 项目规划 明确部分需求（规划项目） 哪些需求可以快速地做出来？ 哪些需求是用户必须使用的？ 讨论规划的可行性 规划好迭代功能和周期 根据第一次迭代规划的需求，进行任务设计和OKR设计，使用Smart指标描述任务 第一次迭代完成后（项目第一个版本） 收集意见整理需求库（需求管理） 从需求库中选择并进行二次规划和迭代（项目规划中的1、2部分） 其他 迭代过程通常需要进行5~6次或更多 上线前需要压测、准备宣传资料","tags":["敏捷开发"],"categories":["Program"]},{"title":"自我使用说明书","path":"/posts/60549.html","content":"心力状态和情绪像天气一样不受控制，解决拖延、心力不足的出发点应该像农民一样，按照不同天气构建不同的应对方式。 很多优秀的人都是拥有一套能够push自己的系统和支撑他们的环境，拖延、行动力不足是因为缺乏这个系统和环境。 不要相信能够使用Passion一直支撑自己，这不符合人的天性，可以使用系统对自己进行客观、标准化的描述。 数据记录（看见自己尚未被觉察的部分）绝大多数人没有想象中了解自己 比如在假期开始前制定的计划，假期结束后有多少能够完成呢？ 缺少无痛启动工作状态的方法和策略 即使知道目标多重要，没有人push的话仍然没有办法完成自己给自己制定的任务。 把心力状态按照最低1星，最高5星这样的状态去计算，制定计划时期的心力状态实际是5星，按照这种是肯定执行不到位的。 所以做计划的时候，要按照自己是3星，甚至是2星的状态去制定，哪怕状态不好的时候也能去推动进展。 但是，很多人不知道，甚至会高估自己做事的3星水平，所以需要使用工具来对自己进行统计： 番茄钟1234567在任务开始和结束时点击，计算自己这次任务时长有多少个番茄钟，如果中途被打断了，使用其他计时器统计被打断的时长，最后在总的时长中减去，这样就可以统计出一天中在这件事上专注了多长时间，用了多少个番茄钟。把每天的番茄钟个数等统计到日记里进行汇总 情绪周期 压迫自己太久后，身体自然会让你变慢下来。这段时间内不需要再逼迫自己赶进度，顺其自然休息一下。 项目管理（尽可能减少内耗）把一件事进行下去并不难，最难的部分在于每天的启动，怎样才能在启动上减少自己的内在阻力呢？ 提高行动的可能性 提高行动概率，降低拖延概率。 不要把重点放在今天怎么没有做？我为什么没有坚持下来这种事情上，而是如果提高下次行动起来的可能性，哪怕行动概率提升10%也是很大的进步。 行动力 &#x3D; 行动的概率 × 时间 工作为什么不喜欢工作也能很好的完成？工作是别人为你设计好的系统，像是在传送带上。同事、老板会不断推着你向前。 自我目标自发想去做的为什么会拖延？理论上内在动机更足，例如：学习、考证、副业等。但是这些没有人管你要结果，也没有deadline，把自己从舒服的状态抓出来做这件事是很累的，身体会默认选择让自己产生多巴胺的行为。 如何设计系统 每天为这个目标工作至少半小时，状态好可以多做一点 尽量简单的开始，状态极差时也能至少完成一分钟的简单工作 目的：每天都能和这件事或者这个方向产生连接，保持一个做事的状态比拥有一大块时间时再启动要容易的多 calender1234567891011使用单独的日历工具安排计划，不要超过3~5天，否则会容易摆烂。如果今天不想做，就把任务拖拽到下一天，并把在今天做的事标注为新任务，拖拽前也要考虑下是卡在哪个任务上，让自己产生了消极情绪，是否任务太难了？如果拆分为多个小任务，能否继续完成？如果还是不行，就拖拽到第二天精力比较好的时候，这时会知道有一个确定的任务在等待完成，会提高推进这件事的可能性。再微小的推进也能极大的刺激自我效能感，因为已经从纠结的心态转变为行动的心态。 系统设计最重要的部分：每天都要和任务产生链接 设计的Tips每次开始工作时进行计时（番茄钟），完成后进行统计归档每个项目刚开始没有头绪时，从问自己问题开始，不断拆解细分。 记录下来，选一些能做的放到3天计划内，如果被卡住了，也要写日记记录下来和自己对话（包括没有心力去执行的时候也是如此）卡住是很正常的，不要等着状态变好再去执行，要学会给自己做心理辅导，不断和自己对话，写着写着大概就能分析出接下来该去做什么了对工作内容进行拆分，并分段计时，查看具体哪个环节花费的时间过长，下次进行改善最重要的是让自己能够轻松启动起来，进入工作状态，把自己哄进工作的轨道，就会自然而然push不需要设计的过于详细，边推进边改动 复盘（需要持续、定期的亲自去做）目的一：定期关照自己的身心状态 是否处于某种惯性中不自知？ 目的二：明确清晰下一步行动 写出下一阶段的任务和目标 周复盘记录本周（实事求是）需要记录本周做了哪些事情计划下一周（通常只做3天的计划） 复盘模板示例回顾目标，评估结果输入输出改善提升身心其他下周的任务关键任务记录项目还能如何拆分？分析原因，总结原因遇到了哪些困难和卡点，做了哪些尝试？可以做哪些改变，可以让下周更好？ 月复盘&#x2F;季度复盘重点不是记录做了什么事情，而是反思和规划这段时间做了哪些项目，遇到什么问题（5Why），自己的想法，有没有改变等使用奥德赛模型询问自己恐惧假设，担心自己某些事情得到不好的结果时，问自己一些问题 复盘模板示例回顾目标，评估结果这个有有哪些产出和改善？自述一下工作状态分析原因，总结原因OKR进度如何？遇到了哪些问题？（至少问自己5个问题）改善的措施思考一下这个月发生的事情，老天爷想告诉你什么信息？规划未来行动奥德赛计划如果我继续现在的到了，五年后的生活该是什么样子？如果我走一条完全不同的道路，五年后的生活该是什么样子？如果我走一条完全不同的道路，不担心钱也不在意别人的眼光，五年后的生活该是什么样子？接下来的12个月，在生活的不同方面，你希望庆祝什么？发现自己有恐惧的事情时再写这个 恐惧假设？当你担心某件事有不好的结果时，试着问自己以下的问题如果我做了这件事，最糟糕的情况是什么？我可以做些什么来防止这些最糟糕的情况发生？如果最糟糕的情况真的发生，我可以做些什么弥补？尝试做这件事的好出是什么？如果我不做这件事情，六个月、一年、三年的生活会是什么样子？ 持续改善 把所有改善措施单独拎出来（Kaizen系统） 一开始很容易做得形式化，沉迷于各种各样的复盘模型，花里胡哨，只要坚持做下去，就会自然地精简掉那些矫情的部分，慢慢接近复盘最核心的意义：让自己定期地记录和反思，在这个过程里关照自己内心的真正需求。 结语如果没有支持帮助你的外在环境和力量，就可以建立一些自我支持的系统，多关照自己的内心，保护好自己的念头 向外寻求帮助是一种方法，自我支持也是一种坚实的力量，佛家讲：每人都是本自具足的 不要专注于目标、系统，而是专注于自己的内心 人的内心和想法很多是受身体和外在环境影响的，当一些因素满足时，有些行为的发生是必然的 KISS常用于活动策划落地或者项目执行结束后总结时使用。 K（Keep） 需要保持的：哪些做得好，以后继续保持。 I（Improve） 需要改进的：哪些不理想，后续需要改进。 S（Stop） 需要停止的：哪些不利行为，需要停止。 S（Start） 需要开始的：哪些东西缺失，需要开始执行。 PCDAP（Plan） 计划：确定目标、方针、活动计划。D（Do） 执行：拆解上一步的目标，将其转换为具体行动并且执行。C（Check） 检查：总结执行计划的结果，注意效果，找出问题。A（Action） 行动、处理：对检查的结果进行处理，成功的经验进行肯定并适当标准化；失败的教训加以总结，避免重现。本阶段未解决的问题放到下一个 PDCA 循环。","tags":["个人成长"],"categories":["其他"]}]